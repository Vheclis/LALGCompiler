%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include "reserved_words.h"
	#include "syntactic.h"

	enum special_tokens
	{
		IDENTIFIER = 0,
		INTEGER,
		REAL
	};

	enum args
	{
		ARG_EXE = 0,
		ARG_FILE,
		ARG_SIZE
	};

	char* special_names[] =
	{
		"IDENTIFIER",
		"INTEGER_NUMBER",
		"REAL_NUMBER"
	};

	char* specific(char* str, special_tokens token);
	char* symbol(char* str);
	char* lexical(char* str);
	void error(char *);

	int line = 1;
	int column = 1;
	FILE* yyin;

	#define INC_COL column += strlen(yytext);
	#define INC_LIN line++; column = 1;
%}
%option noyywrap
%% //Rules

\{.*\}	{ INC_COL } /* Commentary LALG */
[ \t\r]	{ INC_COL } /* Line Spacing */
\n		{ INC_LIN } /* Line Break */

[0-9]+\.[0-9]+				{ INC_COL return specific(yytext, REAL); } /* Real Number */
[0-9]+						{ INC_COL return specific(yytext, INTEGER); } /* Integer Number */

':='							{ INC_COL return "ASSIGN_SYMBOL"; } /* Assign */
'<>'							{ INC_COL return "DIF_SYMBOL"; } /* Comparer */
'>='							{ INC_COL return "MAJOR_EQUAL_SYMBOL"; } /* Comparer */
'<='							{ INC_COL return "MINOR_EQUAL_SYMBOL"; } /* Comparer */
[+\-\*\/\(\)\[\]\.,;:=><]		{ INC_COL return symbol(yytext); } /* Operators and Comparer */

[a-zA-Z][a-zA-Z0-9_]*		{ INC_COL return lexical(yytext); } /* Identifiers and Reserved Words */

. { error(yytext); } /* Error */

%%

/* Specific lexical, like numbers and identifiers */
char* specific(char* str, special_tokens token)
{
	/* printf("%s - %s\n", str, token); // Print input and lexical */

	switch(token)
	{
		case INTEGER:
			yylval.intval = atoi(str);
		break;

		case REAL:
			yylval.realval = atof(str);
		break;

		case IDENTIFIER:
		default:
			yylval.strval = strdup(str);
	}
	return special_names[token];
}

/* Print symbol lexical, like operators and comparer */
char* symbol(char* str)
{
	// Look for lexical in perfect hash function
	// generated by gperf (see reserved_words.h)
	const WORD* hash_word = in_word_set(str, strlen(str));

	if(hash_word) // Print if in hash-table
		return hash_word->token;
	// Otherwise it's an error [it's not supposed to enter here]
	return error(str);
}

/* Any other lexical, like keywords and identifiers */
char* lexical(char* str)
{
	// Look for lexical in perfect hash function
	// generated by gperf (see reserved_words.h)
	const WORD* hash_word = in_word_set(str, strlen(str));

	if(hash_word) // Print if in hash-table
		return hash_word->token;
	// Otherwise it's an identifier
	return specific(str, IDENTIFIER);
}

/* Error */
void error(char *str)
{
	/*printf("%s - ERROR\n", str);*/
}

/* Main is now useless, all the computation is made in syntactic
int main(int argc, char *argv[])
{
	if(argc == ARG_SIZE) // Read from file if has arguments
	{
		yyin = fopen(argv[ARG_FILE], "r");
		yylex();
		fclose(yyin);
	}
	else // Read from stdin
		yylex();
}
*/
